# 编译原理 PA 3 实验报告

计63 陈晟祺 2016010981

## 实验简述

本阶段的实验要求是将带属性修饰的抽象语法树翻译为三地址码（TAC），包括两次扫描阶段。提供的实验框架中已经包含了对 Decaf 现有文法的翻译支持，需要添加对 PA2 中指定的所有新增文法的支持。最终生成的代码在 TAC 虚拟机上运行。

## 主要工作

### 对象浅复制 scopy 语句

语法为 `scopy(identifier, expr);`，要求为将 `expr` 对应的类实例中的所有基础数据类型成员拷贝到 `identifier` 中，而类成员只需要复制引用即可。

实现在 `Translate` 类添加 `genObjectCopy` 方法，仿照 `genNewForClass` 方法的实现，只需要对目标符号实现分配空间、初始化（使用 `expr` 对象的内容）和关联到对应类的虚表即可。具体的实现是将 `expr` 所指对象的每一个 field 依次复制到目标对象中，这对于 int、bool 和引用类型都是自然的；而对于 string，由于 decaf 中的字符串都是不可变的，而且没有 GC 机制的干扰，因此直接复制引用也是可行的。

### `sealed` 属性

语法为 `sealed class identfier {}`。

此特性无需在此阶段进行支持。

### 串行条件卫士

语法为 `if { E1:S1 || ... || En:Sn }`

重写 `visitGuardedIf` 方法，对语法结构中每一个语句对（条件+语句块），顺次进行计算和执行（如果需要）。由于构建 AST 时不会产生空对象，而是空列表，因此无需进行特别处理，直接 accept 即可。

### 简单类型推导

语法为 `var x = Expr;`，并且此语句只会出现在 assign 的左侧。

修改 PA2 中，`TypeCheck` 阶段的 `visitDeductedVar` 方法，将该类型节点的 `lvKind` 赋值为 `LOCAL_VAR`（因为只可能为局部变量）。

重写 `visitDeductedVar` 方法，在其中访问 `DeductedVar` 类的 `VarDef` 属性，关联相应的符号。修改 `visitAssign` 方法，对于左侧是 `LOCAL_VAR` 赋值语句，判断实际类型是 `Ident` 或者 `DeductedVar`（因为二者获取关联符号的方法不同）生成赋值语句。

### 数组操作

#### 数组初始化常量表达式

语法为 `E %% n`。其中 `E` 只会为基础数据类型或者 class，需要使用浅复制。

修改 `Translator` 类中的 `genNewArray` 方法，为其添加参数，使其在创建数组的同时能为每一个元素赋予同样的初值。如果这个值是基础数据类型，则直接进行复制；如果是 class 类型，则调用上面的 `genObjectCopy()` 方法生成浅复制后对象存入数组中。

修改 `visitNewArray` 方法，使得已有初始化数组时传入的初值默认为 0。修改 `visitBinaryOperator` 方法，增加对 `ARRAYREPEAT` 运算符的支持，并在生成代码前检查 `n` 是否为非负数（使用 `Translator` 类中新增的 `genCheckArrayRepeatLength` 方法），否则报错。而后根据 `E` 是否为 class 调用相应的方法。

#### 数组下标动态访问表达式

语法为 `E[E1] default E'`。如果 `E1` 不是 `E` 的合法下标则返回 `E'`，否则与数组访问行为一致。

重写 `visitArrayElement` 方法，首先检查 `E1` 的值是否在 `E` 的长度范围内，如果是，则根据 `visitIndexed` 中的方法进行数组访问。如果不是，再对 `E'` 进行求值，并返回 `E'` 的值。

#### 数组迭代语句

语法为 `foreach (var x in E while B) S` 或 `foreach (Type x in E while B) S`。此语句的执行要求比较复杂，实现如下：

重写 `visitForeach` 方法，在其中对整个数组 `E` 进行遍历。每次取出数组的一个元素，赋值给 `x`，并执行 `B` 中条件判断，如果不满足则直接退出。然后执行 `S` 中的语句。完成后对下一个元素重复上述操作，直到数组遍历完毕。为了支持 `S` 中的 `break` 语句，在每次进入 `S` 前压 `lookExits` 栈，在退出后弹栈。

描述该过程的伪码如下：

```text
length = E.length
i = 0

judge:
    if (i >= length) goto exit
    x = source[i]
    if (!B) goto exit;
    S()
    i = i + 1

exit:
```

### 除零错误检查

实验中要求对除数和模数进行运行时检查，防止其为 0。只需要新增对应的异常字符串表示，并修改 `visitBinary` 方法，在这两个操作符生成代码之前插入检查函数（`Translator` 中的 `genCheckDivisor` 方法）即可。

## 遇到问题

### 文件不一致

PA3 一些标注为 “不需修改” 的文件中的类定义事实上缺乏一些 PA2 中类型检查需要的属性，如 `Class` 类和 `LocalScope` 类。补全即可。

### 内存泄漏

在 scopy 等语句的实现过程中，都存在潜在的内存泄漏问题（事实上整个 decaf 的设计都没有考虑到这一点），如一个对象不再有引用后，依旧存在内存中。可以添加一些简单的判断（如 scopy 不重复初始化对象等），但事实上都是治标不治本的方法。更好的解决方法应该是为语言添加一个全局 GC，或者实现引用计数等特性。

### 未初始化对象

如果不初始化某个对象就进行使用，由于其默认指向地址 0，可能会引发很多无法预料的行为，这给我的编码、调试过程带来了不少的麻烦。认识到这一点后，解决是很简单的。

### TAC VM 的其他问题

如测例中的 `q1-scopy-test1.decaf`，其中 `Father` 类的 `getA` 方法没有事实上返回值，但是却可以正常工作。这不是语法所支持的，因此不是预期的行为。